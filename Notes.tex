
%Prefacio
\include{Prefacio}

\title{Category Theory and \\ Computational Complexity}
\author{Marco Larrea \and Octavio Zapata}

\begin{document}
\maketitle

\section{Ponle Nombre a Tu Seccion wey}
A first-order dependence logic $\D$ is a class which consists of all $\D$-definable properties where $\D := (\FO + \mu.\bar{t})$ and $\mu.\bar{t}$ denotes that term $t_{|\bar{t}|}$ is functionally dependent on $t_{i}$ for all $i\leq |\bar{t}|$. Recall that a $P$-definable property is a closed under isomorphism class $P$ of structures. The model class of a first-order sentence $\varphi$ is the class of structures $\Mod(\varphi):=\{A:A\models\varphi\}$ where the notation $A\models\varphi$ refers to the \emph{`the snow is white' iff the snow is white} type of Tarskian semantics, of $\varphi$ being true when interpreted in $A$ under all $\alpha$ assignment functions (i.e. ($\forall\alpha\in [A]^{Var})\ A\models\varphi[\alpha]$ with $Var$ some usable variables). 

The model class $\FO$ is, as always, defined as the class of models of all first-order sentences (i.e. $\FO:= \{S:(\exists\tau)(\exists\varphi\in L(\tau))\ S=\Mod(\varphi)\}$ where $L(\tau)$ is a first-order language of type $\tau$) and $\mu.\bar{t}$ is interpreted as a recursively generated tuple of terms $(t_1,\dots,t_{|\bar{t}|})$ which we naturally identify with the set $[|\bar{t}|] := \{1,2,\dots,|\bar{t}|\}$. $\D$ sentences are capable to characterise variable dependence and in general they are proven to be as expressive as the sentences of the second order $\Sigma_1^1$ fragment \cite{dep}. The intuitionistic dependence version $\ID$ has the same expressive power as full $\SO$ \cite{dep}. It is a fact that $\MID$-model checking is $\PSPACE$-complete \cite{dep} where $\MID$ is the intuitionistic implication fragment of the modal dependence logic $\MD$ which contains at least two modifiers. Hence, $(\FO + \mu.\bar{t}) = \NP, \ID = \Sigma_{\ast}\P$ and $\MID = \PSPACE$.  On the other hand, $\PSPACE = \IP = \QIP$ \cite{qip}, and so $\MID = \QIP$ which is the quantum version of the interactive polytime class $\IP$.

We shall try to cook up a purely algebraic definition for the class of structures $\MID$ and extend such categorical logic in order to capture other quantum and classical complexity classes. 

Ehrenfeucht-Fra\"iss\'e games characterise the expressive power of logical languages \cite{ams}. Every Ehrenfeucht-Fra\"iss\'e game is an ultraproduct \cite{models}. A back-and-forth method for showing isomorphism between countably infinite structures. If $F$ is an ultrafilter (i.e. $F\subseteq 2^{\mathbb{N}}$ and $\forall X\subseteq\mathbb{N} (X\notin F \Leftrightarrow \mathbb{N}\setminus X\in F)$ holds) then the reduced product $\prod_{i}M_i / F$ is an ultraproduct of the sets $M_i$, $i\in I$. Recall that \[f\sim g \Leftrightarrow \{i\in I : f(i) = g(i)\}\in F\] for all infinite sequences $f,g\in\prod_i M_i$ and any index set $I$ is the relation which induces the equivalence classes that conform the ultraproduct \[\prod_{i}M_i / F = \{[f]:f\in\prod_i M_i\}.\] 

\begin{lem}[$\defaultL$o\'s Lemma]
If $F$ is an ultrafilter and $\varphi$ a first-order formula, then the ultraproduct of models of $\varphi$ indexed by any index set $I\in F$ is a model of $\varphi$, i.e. \[\prod_i A_i / F \models\varphi\Leftrightarrow\{i\in I: A_i\models\varphi\}\in F.\]
\end{lem}

\section{Categorical Semantics of the Lambda Calculus}


The $\lambda-$calculus is an abstraction of the theory of functions,
in the same way group theory is an abstraction of the theory of
symmetries. There are two basic operation on function we would like to
formalize, \emph{application} and \emph{abstraction}.

Application refers to the operation performed by a function on a given
term or expression. For example, if $double$ is the function that
multiplies by two, then for any given natural number $n$, we can apply
$double$ to $n$ to form the new natural number $double(n) = 2n$. Note
that in order to be consistent one should define the type of
arguments a function can take, for instance, it makes no sense to
apply $double$ to a string ``$string$'' of characters. 

Abstraction is the operation of introducing new functions. Given a
term $t$ which (possibly) depends on a variable $x$, we can form a
new function by abstracting the variable $x$ from the term $t$ in such a
way that the application of this function on a term $u$ is given by
substituting in $t$ the variable $x$ by $u$. So for example, if we
have the term $t = x * 2$ which depends on $x$, we form the function
$\lambda x.t$ which extensionally is the same as the function $double$
from above, that is $\lambda x.t(n) = double(n) = 2n$ for all natural
number $n$.

The \emph{simply-typed lambda calculus} is a form of type theory that
interpretes the $\lambda$-calculus. Types are used in order to improve
the consistency of the originally untyped theory.

The first step to define the simply-typed lambda calculus is to fix a
set $\beta$ whose elements we name \emph{basic types} or \emph{atomic types}. We
express the fact that an object is a \emph{type} by the judgment:
\[
A \ type
\]

We want every element of $\beta$ to be a type, for this we introduce an
\emph{axiom} which is a special kind of \emph{deduction rule} for which
there are no assumptions. So for each $A \in \beta$ we have the rule:

\begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$A \ type$}
\end{prooftree}
which is read ``$A$ is a type''. We'll also want to have a special
type with only one term which we shall name the \emph{unit type}:

\begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$1 \ type$}
\end{prooftree}


\nocite{*}
\bibliographystyle{alpha}
\bibliography{paper}

\end{document}
