
%Prefacio
\include{Prefacio}

\title{Category Theory and \\ Computational Complexity}
\author{Marco Larrea \and Octavio Zapata}

\begin{document}
\maketitle

\section{Introduction}

\subsection{First-order dependence}

In this section every vocabulary $\tau$ will be referred as a similarity type or simply as a type.

The model class $\FO$ is, as always, defined as the class of models of all first-order sentences, i.e. $\FO:= \{S:(\exists\tau)(\exists\varphi\in L(\tau))\ S=\Mod(\varphi)\}$ where $L(\tau)$ is a first-order language of type $\tau$.

A first-order dependence logic $\D$ is a class which consists of all $\D$-definable properties where $\D := (\FO + \mu.\bar{t})$ and $\mu.\bar{t}$ denotes that term $t_{|\bar{t}|}$ is functionally dependent on $t_{i}$ for all $i\leq |\bar{t}|$. The model class $\FO$ is as always defined as the class of models of all first-order sentences (i.e. $\FO:= \{S:(\exists\tau)(\exists\varphi\in L(\tau))\ S=\Mod(\varphi)\}$ where $L(\tau)$ is a first-order language of type $\tau$) and $\mu.\bar{t}$ is interpreted as a recursively generated tuple of terms which we naturally identify with the set $[|\bar{t}|] := \{1,2,\dots,|\bar{t}|\}$. $\D$ sentences are capable to characterise variable dependence and in general they are proven to be as expressive as the sentences of the second order existential $\SO\exists$ model class \cite{dep}. The intuitionistic dependence version $\ID$ has the same expressive power as full $\SO$ \cite{dep}. It is a fact that $\MID$-model checking is $\PSPACE$-complete \cite{dep} where $\MID$ is the intuitionistic implication fragment of the modal dependence logic $\MD$ which contains at least two modifiers. Hence, $(\FO + \mu.\bar{t}) = \NP, \ID = \Sigma_{\ast}\P$ and $\MID = \PSPACE$.  On the other hand, $\PSPACE = \IP = \QIP$ \cite{qip}, and so $\MID = \QIP$ which is the quantum version of the interactive polytime class $\IP$.

We shall try to cook up a purely algebraic definition for the class of structures $\MID$ and extend such categorical logic in order to capture other quantum and classical complexity classes. 

\subsection{Ultraproduct}

Ehrenfeucht-Fra\"iss\'e games characterise the expressive power of logical languages \cite{ams}. Every Ehrenfeucht-Fra\"iss\'e game is an ultraproduct \cite{models}, a back-and-forth method for showing isomorphism between countably infinite structures, but only defined for finite structures in finite model theory. If $F$ is an ultrafilter (i.e. $F\subseteq 2^{\mathbb{N}}$ such that $\forall X\subseteq\mathbb{N} (X\notin F \leftrightarrow \mathbb{N}\setminus X\in F)$ holds) then the reduced product $\prod_{i}M_i / F$ is an ultraproduct of the sets $M_i$, $i\in I$. Recall that \[f\sim g \Leftrightarrow \{i\in I : f(i) = g(i)\}\in F\] for all infinite sequences $f,g\in\prod_i M_i$ and any index set $I$, is the relation which induces the equivalence classes that conform the ultraproduct \[\prod_{i}M_i / F = \{[f]:f\in\prod_i M_i\}.\] 

This mathematical tool (the ultraproduct) is widely important because of results such as the following, from which proof we will delayed for the moment.

\begin{lem}[$\L$o\'s Lemma]
If $F$ is an ultrafilter and $\varphi$ a first-order formula, then the ultraproduct of models of $\varphi$ indexed by any index set $I\in F$ is a model of $\varphi$, i.e. \[(\prod_i A_i / F , \alpha)\models\varphi\Leftrightarrow\{i\in I: (A_i, \alpha_i)\models\varphi\}\in F.\]
\end{lem}

\subsubsection{Ultrafilters}
Given a nonempty set $L$ define a binary relation $\succ$ on it by forcing the following formulas true:
\begin{itemize} 
\item[1.] Reflexivity: $\forall x (x\succ x)$
\item[2.] Transitivity: $\forall xyz (x\succ y)\land (y\succ z)\rightarrow (x\succ z)$
\item[3.] Antisymmetry: $\forall xy (x\succ y)\land (y\succ x)\rightarrow (x=y)$ 
\end{itemize}
The pair $\langle L, \succ \rangle$ is called a \emph{poset} and $\succ$ a \emph{partial order} on $L$. For every two-element subset $\{x,y\}$ of $L$ we define its \emph{meet} and \emph{join} as $x\sqcap y := \inf_{\succ}\{x,y\}$ and $x\sqcup y := \sup_{\succ}\{x,y\}$, respectively. A \emph{lattice} is a poset where every two-element subset has meet and join (i.e. $\forall\{x,y\}\in 2^L(\exists (x\sqcap y)\in L\land\exists (x\sqcup y)\in L)$ is satisfied).

A \emph{filter} is a subset $F$ of a lattice $L$ which contains all the \emph{successors} of any member of $F$ (i.e. $\forall xy(y\in F)\land(x\succ y)\rightarrow(x\in F)$ holds). An \emph{ultrafilter} $U$ is a maximal filter with respect to the usual partial order relation that one can always define on any Boolean algebra (particularly on $2^L$).
%\subsection{Descriptive complexity}
%%
%%
%Recall that a partial function $f$ is said to be \emph{computable} if there is a Turing machine $M$ such that $f$ is computed by $M$ (cf. Definition \ref{df:7}). Let us consider two languages $\mathcal{A, B}$ over the alphabet $\Sigma$, and a family of functions $\F$ from $\Sigma^{\ast}$ to itself that is closed under composition. We say that $\mathcal{A}$ is \emph{reducible} to $\mathcal{B}$ \emph{under} $\F$, if there is a function $f\in\F$ such that for all $x\in\Sigma^{\ast}$ we have $f(x)\in B$ if and only if $x\in \mathcal{A}$. We denote this by $\mathcal{A}\leq_{\F} \mathcal{B}$. Then, we say that $\mathcal{A}\leq_f \mathcal{B}$ is a polynomial time reduction from $\mathcal{A}$ to $\mathcal{B}$ if $f$ is computable in polynomial time, and we write $\mathcal{A}\leq_{\p} \mathcal{B}$ to denote this. If $f$ is definable by a first-order formula, then say that $\mathcal{A}\leq_{\FO} \mathcal{B}$ is a first-order reduction.
%
%Now, let $\S\subseteq 2^{\Sigma^{\ast}}$ be a set of languages over the alphabet $\Sigma$, and $\F$ a family of functions from $\Sigma^{\ast}$ to itself . We say that $\S$ is \emph{closed under} $\F$-reductions if for each $\mathcal{S}\in\S$ there is a function $f\in\F$ such that for all $\mathcal{L}\subseteq\Sigma^{\ast}$ \[\mathcal{L}\leq_{f}\mathcal{S}\ \text{ implies }\ \mathcal{L}\in\S.\]
%
%We say that a language $\mathcal{L}\subseteq\Sigma^{\ast}$ is \emph{hard} for $\S$ if every language $\mathcal{S}\in\S$ reduces to $\mathcal{L}$. That is, for each $\mathcal{S}\in\S$ there is a function $f\in\F$ such that $\mathcal{S}\leq_{f}\mathcal{L}$. Also, we say that a language $\mathcal{L}\subseteq\Sigma^{\ast}$ is \emph{complete} for $\S$ if $\mathcal{L}$ is hard for $\S$ and $\mathcal{L}\in\S$.
%
%Then, let us notice that computational problems may be encoded as binary strings $x\in\{0,1\}^{\ast}$, decision problems as languages $\mathcal{L}\subseteq\{0,1\}^{\ast}$, and complexity clases as sets $\C\subseteq 2^{\{0,1\}^{\ast}}$ of languages. Equivalently, each formula $\varphi\in\LL[\tau]$ express a computational problem, each class of structures $\mathcal{P}\subseteq\Str[\tau]$ describes a decision problem, and each logic $\LL$ embraces a complexity class. 
%
%We will write $\LL = \C$ to denote that the logic $\LL$ embraces the complexity class $\C$, that is, when every \emph{instance} of $\C$ can be described by an $\LL$-definable property. By an instance of a complexity class $\C$ we mean any language $\mathcal{L}\in\C$ that is complete for $\C$ via first-order reductions. 
%
%The general procedure to prove that $\LL = \C$ will be the following:
%\begin{itemize}
%\item[1.] For each $\varphi\in\LL[\tau]$, produce an algorithm in $\C$ that decides the set \[\Mod[\varphi] = \{A:A\models\varphi\}.\]
%\item[2.] Produce a language $\mathcal{L}$ complete for $\C$ via first-order reductions.
%\item[3.] Show that $\LL$ is closed under first-order reductions.
%\item[4.] Describe a $\LL$-definable property $\mathcal{P}$ such that $\mathcal{L} = \mathcal{L}(\mathcal{P})$. 
%\end{itemize}

\section{Categorical Semantics of the Lambda Calculus}


The $\lambda-$calculus is an abstraction of the theory of functions,
in the same way group theory is an abstraction of the theory of
symmetries. There are two basic operation on function we would like to
formalize, \emph{application} and \emph{abstraction}.

Application refers to the operation performed by a function on a given
term or expression. For example, if $double$ is the function that
multiplies by two, then for any given natural number $n$, we can apply
$double$ to $n$ to form the new natural number $double(n) = 2n$. Note
that in order to be consistent one should define the type of
arguments a function can take, for instance, it makes no sense to
apply $double$ to a string ``$string$'' of characters. 

Abstraction is the operation of introducing new functions. Given a
term $t$ which (possibly) depends on a variable $x$, we can form a
new function by abstracting the variable $x$ from the term $t$ in such a
way that the application of this function on a term $u$ is given by
substituting in $t$ the variable $x$ by $u$. So for example, if we
have the term $t = x * 2$ which depends on $x$, we form the function
$\lambda x.t$ which extensionally is the same as the function $double$
from above, that is $\lambda x.t(n) = double(n) = 2n$ for all natural
number $n$.

The \emph{simply-typed lambda calculus} is a form of type theory that
interpretes the $\lambda$-calculus. Types are used in order to improve
the consistency of the originally untyped theory.

The first step to define the simply-typed lambda calculus is to fix a
set $\beta$ whose elements we name \emph{basic types} or \emph{atomic types}. We
express the fact that an object is a \emph{type} by the judgment:
\[
A \ type
\]

We want every element of $\beta$ to be a type, for this we introduce an
\emph{axiom} which is a special kind of \emph{deduction rule} for which
there are no assumptions. So for each $A \in \beta$ we have the rule:

\begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$A \ type$}
\end{prooftree}
which is read ``$A$ is a type''. We'll also want to have a special
type with only one term which we shall name the \emph{unit type}:

\begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$1 \ type$}
\end{prooftree}

There are two introduction rules for types, these rules tell us how to construct new types from old ones. There is the introduction rule for \emph{product types}:


\begin{prooftree}
      \AxiomC{$A \ type$}
      \AxiomC{$B \ type$}
      \BinaryInfC{$A \times B \ type$}
\end{prooftree}
and the introduction rule for \emph{function types}:

\begin{prooftree}
      \AxiomC{$A \ type$}
      \AxiomC{$B \ type$}
      \BinaryInfC{$A \rightarrow B \ type$}
\end{prooftree}

Therefore the set of all types of the simply-typed lambda calculus is recursively generated from the set of basic types by applying the introduction rules of products and functions. 

Now the set of types is defined we would like to define in a similar way the set of terms. As before we fix a set of \emph{constant terms} or just \emph{constants}. We also asume there are countable many variables (or as many as we might need), we'll name the variables $x, y, z, \dots$. Just as types we will recursively generate the set of terms as follows:
\[
t := [variables] | [constants] | * | <t , t'> | \pi_1 t | \pi_2 t | t(t') | \lambda x.t
\]

\nocite{*}
\bibliographystyle{alpha}
\bibliography{paper}

\end{document}
